### Functions for Calculating global TMB from whole exome mutation data

abridge <- function(maf_file, nonsilent = TRUE, by_study = FALSE) {
# Takes a maf file and selects the characteristics required to perform TMB analysis
# and removes duplicate entries (which exist for a variety of reasons, consult
# the TCGA website)
# Requires tidyverse
    
    if ("Start_position" %in% colnames(maf_file)) {
        maf_file <- mutate(maf_file, Start_Position = Start_position) %>%
            select(-Start_position)
    }
    
    if ("End_position" %in% colnames(maf_file)) {
        maf_file <- mutate(maf_file, End_Position = End_position) %>%
            select(-End_position)
    }
    
    if (by_study) {
        data_abridged <- maf_file %>% 
            select(Hugo_Symbol, Chromosome, Start_Position, End_Position, Variant_Classification, Variant_Type, Tumor_Sample_Barcode, study) %>% 
            distinct()
    }
    else {
        data_abridged <- maf_file %>% 
            select(Hugo_Symbol, Chromosome, Start_Position, End_Position, Variant_Classification, Variant_Type, Tumor_Sample_Barcode) %>% 
            distinct()   
    }

    if (nonsilent == TRUE) {
        data_abridged <- data_abridged %>% 
            filter(Variant_Classification %in% c('Frame_Shift_Del', 'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins', 'Missense_Mutation', 'Nonsense_Mutation', 'Nonstop_Mutation', 'Splice_Site', 'Translation_Start_Site'))
              }
    return(data_abridged)
}


cbio_getData <- function(path_name, cancer_type, by_cancer = FALSE, test = TRUE, training = 0.7, nonsilent = TRUE) {
    
    data <- tibble(Hugo_Symbol = character(), Chromosome = character(), 
                                 Start_Position = vector(), End_Position = vector(), 
                                 Variant_Classification = character(), Variant_Type = character(), 
                                 Tumor_Sample_Barcode = character(), study = character())
    
    for (i in 1:length(dir(path_name))) {
        
        if ("data_mutations_extended.txt" %in% dir(paste0(path_name, "/", dir(path_name)[i]))) {
            study_meta <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/meta_study.txt"), col_names = FALSE, comment = "#")
            cancer <- substr(study_meta[1,],17,nchar((study_meta[1,])))
            
            if (cancer %in% cancer_type) {
                print(dir(path_name)[i])
                new_data <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/data_mutations_extended.txt"), comment = "#") 
                if (all(substr(new_data$Chromosome, 1, 3) == "chr")) {
                    new_data$Chromosome <- substr(new_data$Chromosome, 4, 6)
                }
                if (all(!is.na(new_data$Chromosome))) {
                    new_data <- abridge(new_data, nonsilent)
                    print(new_data %>% 
                             count(Tumor_Sample_Barcode) %>% 
                             nrow())
                    new_data$Tumor_Sample_Barcode <- as.character(new_data$Tumor_Sample_Barcode) 
                    new_data$Chromosome <- as.character(new_data$Chromosome)

                    if (nrow(new_data) > 0) {
                        new_data$study <- dir(path_name)[i]
                        if (by_cancer) {
                            new_data$cancer_type <- cancer
                        }
                    }
                    data <- bind_rows(data, new_data) 
                   
                    data$Hugo_Symbol <- make.names(data$Hugo_Symbol)
                    
                }
            }
        }
    }
    print(data %>% 
             count(Tumor_Sample_Barcode) %>% 
             nrow())
    if (test == TRUE) {
        tumor_ids <- unique(data$Tumor_Sample_Barcode)
        
        training_sample <- sample(length(tumor_ids), floor(training*length(tumor_ids)))
        test_sample <- setdiff(1:length(tumor_ids), training_sample)
        print(length(training_sample))
        print(length(test_sample))
        training_ids <- tumor_ids[training_sample]
        test_ids <- tumor_ids[test_sample]
        
        training_data <- data %>% 
            filter(Tumor_Sample_Barcode %in% training_ids)
        test_data <- data %>% 
            filter(Tumor_Sample_Barcode %in% test_ids)
        
        out <- list(training_ids, test_ids, training_data, test_data)
        names(out) <- c("training_ids", "test_ids", "training_data", "test_data")
        return(out)
    }
    else {
        return(data)
    }
}

cbio_getCancerTypes <- function(path_name) {
    cancer_types <- c()
    for (i in 1:length(dir(path_name))) {
        if (!("data_mutations_extended.txt" %in% dir(paste0(path_name, "/", dir(path_name)[i])))) {
            print(paste0("Their is no mutations file in ", dir(path_name)[i]))
        }
        else {
            study_meta <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/meta_study.txt"), col_names = FALSE, comment = "#")
            cancer <- substr(study_meta[1,],17,nchar((study_meta[1,])))
            cancer_types <- unique(c(cancer_types, cancer))
        }
    }
    return(cancer_types)
}

cbio_getDataSets <- function(path_name, cancer_type) {
    data_sets <- c()
    
    for (i in 1:length(dir(path_name))) {
        if (!("data_mutations_extended.txt" %in% dir(paste0(path_name, "/", dir(path_name)[i])))) {
        print(paste0("Their is no mutations file in ", dir(path_name)[i]))
        }
        else {
            study_meta <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/meta_study.txt"), col_names = FALSE, comment = "#")
            cancer <- substr(study_meta[1,],17,nchar((study_meta[1,])))
            if (cancer == cancer_type) {
                data_sets <- c(data_sets, dir(path_name)[i])
            }
        }
    }
    return(data_sets)
}

TMB_Calc <- function(maf_file, nonsilent = TRUE) {
# Takes a maf file and outputs a table with tumor sample barcode and TMB value
# Requires tidyverse to be installed
# Depends on previous function 'abridge()'
    
    if ("study" %in% colnames(maf_file)) {
        tmb_table <-  maf_file %>%  
                abridge(nonsilent = nonsilent, by_study = TRUE) %>% 
                group_by(Tumor_Sample_Barcode, study) %>% 
                summarise(TMB = n()/30)
        }
    else {
        tmb_table <-  maf_file %>%  
                abridge(nonsilent = nonsilent) %>% 
                group_by(Tumor_Sample_Barcode) %>% 
                summarise(TMB = n()/30)     
    }
    
    return(tmb_table)
}


### Functions for calculating association local vs global for a given window 

Local_TMB_Calc <- function(maf_file, Chrom, Start, Window_Size, ns = FALSE, pre_abridged = FALSE) {
# takes a maf file and outputs a table with tumor sample barcode and local TMB 
# value for the window specified via chromosome, start position and window size
# requires tidyverse to be installed
# requires function 'abridge()'
    
    all_samples <- tibble(Tumor_Sample_Barcode = unique(maf_file$Tumor_Sample_Barcode))
    
    if (pre_abridged == FALSE) {
        maf_file <- abridge(maf_file, nonsilent = ns)
    }
    
    local_tmb_table  <- maf_file %>% 
        filter(Chromosome == Chrom) %>% 
        filter(Start_Position %in% (Start + 0:(Window_Size-1))) %>% 
        group_by(Tumor_Sample_Barcode) %>% 
        summarise(Local_TMB = n())
    
    local_tmb_table <- full_join(all_samples, local_tmb_table, by = "Tumor_Sample_Barcode")
    local_tmb_table[is.na(local_tmb_table)] <- 0
    
    return(local_tmb_table)
}

getPs <- function(local_tmb_table, global_tmb_table) {
# Takes a local tmb table and a global tmb table and returns the significance of their correlation
# Not currently set up to account for multiple testing
# Requires tidyverse
    
    comparison_table <- inner_join(local_tmb_table, global_tmb_table,
           by = "Tumor_Sample_Barcode") 
    #creates a table with Tumor sample barcode, global burden and local burden
    
    if (sum(comparison_table$Local_TMB != 0) > 0) {
    return(summary(lm(TMB~Local_TMB, comparison_table))$coefficients[2,4])
        }
    else {
        return(1)
    }
}

### Functions for a first pass window algorithm


chromosome_slide <- function(maf_file, global_tmb_table = NULL, Chromosome, window_size, jump_length, ns = FALSE) {
# performs a sliding window algorithm on one chromosome
# outputs a vector of significances
# can be given a global tmb table, otherwise will calculate itself
# requires a genome to be loaded under name 'genome', ideally GChr37
# requires packages tidyverse, BSGenome and functions abridge, TMB_Calc, Local_TMB_Calc and getSignificance 
    
# NOTE there's a weird thing going on at the moment where "global_tmb_table = NULL" must be explicitly fed 
# to the function, else it doesn't work
    
    chromosomes <- c(1:22, "X", "Y")
    
    if (is.null(global_tmb_table)) {
        global_tmb_table <- TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    chromosome_length <- length(genome[[which(chromosomes == Chromosome)]])
    position_vector <- seq(from = 1, to = chromosome_length - window_size, by = jump_length)
    len <- length(position_vector)
    key_vector <- (1:len)/len
    chromosome_vector <- rep(Chromosome, len)
    p_vector <- map_dbl(position_vector, ~Local_TMB_Calc(maf_file, Chrom = Chromosome, Start = .x, Window_Size = window_size, pre_abridged = TRUE) %>% 
                                                      getPs(global_tmb_table))
    significance_vector <- -log(p.adjust(p_vector, method = "BH"))
    return(tibble(chromosome = chromosome_vector, position = position_vector, key = key_vector, significance = significance_vector))
    
}

genome_slide <- function(maf_file, global_tmb_table = NULL, window_size, jump_length, ns = FALSE) {
    chromosomes <- c(1:22,"X","Y")
    genome <- BSgenome.Hsapiens.UCSC.hg19
    if (is.null(global_tmb_table)) {
        global_tmb_table = TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    genome_association <- tibble(chromosome = character(), position = vector(), key = vector(), significance = vector())
    
    
    for (n in 1:24) {
        message(chromosomes[n])
        genome_association <- bind_rows(genome_association, chromosome_slide(maf_file, global_tmb_table, chromosomes[n], window_size, jump_length))   
    }
    
    return(genome_association)
    
}


chromosome_restricted_slide <- function(maf_file, previous_run, zoom = 10, global_tmb_table = NULL, Chromosome, ns = FALSE, coverage = 10) {

 
    chromosomes <- c(1:22, "X", "Y")
    
    old_jump_length <- as.numeric(previous_run[2,"position"] - previous_run[1,"position"])
    
    new_jump_length <- max(1,floor(old_jump_length/zoom))
    new_window_size <- coverage*new_jump_length
    
    quant <- 1 - 1/zoom
    
    significant_positions <- previous_run %>% 
        filter(significance > quantile(significance, quant)) %>% 
        filter(chromosome == Chromosome)  
        
    
    chromosome_positions <- c()
    for (position in significant_positions$position) {
        chromosome_positions <- c(chromosome_positions, seq(from = position, to = position + old_jump_length - new_jump_length, by = new_jump_length))
    }
    
    if (is.null(global_tmb_table)) {
        global_tmb_table <- TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    len <- length(chromosome_positions)
    chromosome_vector <- rep(Chromosome, len)
    key_vector <- (1:len)/len
    p_vector <- map_dbl(chromosome_positions, ~Local_TMB_Calc(maf_file, Chrom = Chromosome, Start = .x, Window_Size = new_window_size, pre_abridged = TRUE) %>% 
                                                              getPs(global_tmb_table))
    
    significance_vector <- -log(p.adjust(p_vector, method = "BH"))
    if (len > 0) {
        return(tibble(chromosome = chromosome_vector, position = chromosome_positions, key = key_vector, significance = significance_vector))
    }
    else {
        return(tibble(chromosome = character(), position = vector(), key = vector(), significance = vector()))
    } 
    
}


genome_restricted_slide <- function(maf_file, previous_run, zoom = 10, global_tmb_table = NULL, ns = FALSE, coverage = 1) {
   
    chromosomes <- c(1:22,"X","Y")
    
    if (is.null(global_tmb_table)) {
        global_tmb_table = TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    genome_association <- tibble(chromosome = character(), position = vector(), key = vector(), significance = vector())
    
    
    for (n in 1:24) {
        message(chromosomes[n])
        genome_association <- bind_rows(genome_association, chromosome_restricted_slide(maf_file, previous_run, zoom, global_tmb_table, Chromosome = chromosomes[n], ns, coverage))   
       
    }
    
    return(genome_association)
    
}
    
RLL_slide <- function(maf_file, starting_window, iterations, zoom, coverage) {
# Compiles a dataframe with iterations in one column and the dataframes giving the
# results of that result of iteration in another
    
    global_tmb_table <- TMB_Calc(maf_file, nonsilent = TRUE)
    
    window_size <- starting_window
    jump_length <- as.integer(window_size/coverage)
    message("Iteration 1")
    full_positions <- genome_slide(maf_file, global_tmb_table, window_size, jump_length)
    
    full_positions$iteration <- rep(1, nrow(full_positions))
    old_positions <- full_positions
    
    for (index in 2:iterations) {
        window_size <- as.integer(window_size/zoom)
        jump_length <- as.integer(jump_length/zoom)
        message(paste("Iteration", index))
        new_positions <- genome_restricted_slide(maf_file, old_positions, zoom, global_tmb_table, coverage = coverage)
        new_positions$iteration <- rep(index, nrow(new_positions))
        
        full_positions <- bind_rows(full_positions, new_positions)
        old_positions <- new_positions
    }
    
    full_positions <- full_positions %>% 
        group_by(iteration) %>% 
        nest()    
    
    full_positions$jump_length <- (starting_window/coverage)/(zoom**(full_positions$iteration - 1))
    
    return(full_positions)
    
}
    

### Functions for producing a training matrix

getWindows <- function(window_run, panel_size, max_windows = 50, coverage = 1) {
    
    
    chromosomes <- c(1:22, "X", "Y")
    working_panel <- tibble(chromosome = factor(character(), levels = chromosomes), position = vector())
    jump_length <- (window_run[2,"position"] - window_run[1, "position"])[1,1]
   
    window_size <- coverage*jump_length
    adding <- TRUE
    
    while (adding) {
        new_position <- window_run %>% 
            filter(significance == max(significance)) %>% 
            filter(chromosome == min(chromosome)) %>% 
            filter(position == min(position)) %>% 
            select(chromosome, position)
        
        if (nrow(working_panel %>% 
            add_row(chromosome = rep(new_position$chromosome[1], coverage), position = new_position$position[1] + jump_length*(0:(coverage-1))) %>% 
            distinct())*jump_length <= panel_size) {
            
            working_panel <- working_panel %>% 
                add_row(chromosome = rep(new_position$chromosome[1], coverage), position = new_position$position[1] + jump_length*(0:(coverage-1))) %>% 
                distinct() %>% 
                group_by(chromosome) %>% 
                arrange(position, .by_group = TRUE) %>% 
                ungroup()
            
        
            window_run <- window_run %>% 
                filter((chromosome != new_position$chromosome)|(position != new_position$position))
        }
        else {
            adding <- FALSE
        }
    }
    
    nonadj_working_panel <- working_panel %>% 
        mutate(seq_id = cumsum(c(1,diff(position)) != jump_length)) %>% 
        group_by(seq_id) %>% 
        nest() %>% 
        mutate(chromosome = map(data, function(data) data$chromosome[1]), 
               position = map(data, function(data) data$position[1]), 
               jumps = map(data, function(data) nrow(data))) %>% 
        select(-c(seq_id, data)) %>% 
        unnest()
          
    n_windows <- nrow(nonadj_working_panel) 
    nonadj_working_panel$cluster <- 1:n_windows       
    set.seed(2019)
                           
    if (n_windows > max_windows) {
        nonadj_working_panel$cluster <- (tibble(x = unlist(map(nonadj_working_panel$chromosome, function(x) which(chromosomes == x)))*10**9, y = nonadj_working_panel$position) %>% 
            kmeans(max_windows))$cluster
    }
    
    return(nonadj_working_panel)
}
                                                           
collapse_col <- function(df, n) {
  
    cols <- setdiff(str_subset(colnames(df), paste0("Window_", n)), str_subset(colnames(df), paste0(n, "[1234567890]")))
    
    return(df %>% 
              select(cols) %>% 
              rowSums()) 
}                                                           

getMatrix <- function(maf_file, candidate_panel, jump_length, global_tmb_table = NULL, ...) {
    
    if (is.null(global_tmb_table)) {
        global_tmb_table = TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    window_matrix <- global_tmb_table
    
    for (n in 1:nrow(candidate_panel)) {
        new_column <- maf_file %>% 
            filter(Chromosome == candidate_panel$chromosome[n]) %>% 
            filter(Start_Position %in% (candidate_panel$position[n] + 0:(jump_length*candidate_panel$jumps[n] - 1))) %>%
            group_by(Tumor_Sample_Barcode) %>% 
            summarise(Window = n())
    
        colnames(new_column) <- c("Tumor_Sample_Barcode", paste0("Window_", candidate_panel$cluster[n]))
        window_matrix <- full_join(window_matrix, new_column, by = "Tumor_Sample_Barcode")
        
    }
    
    window_matrix[is.na(window_matrix)]  <- 0
    
    window_matrix <- ungroup(window_matrix)
    
    collapsed_window_matrix <- global_tmb_table %>% 
        ungroup()
    
    for (n in 1:length(unique(candidate_panel$cluster))) {
        new_column <- window_matrix %>% 
            collapse_col(n)
        
        new_col_names <- c(colnames(collapsed_window_matrix), paste0("Window_", n))
        
        collapsed_window_matrix <- collapsed_window_matrix %>% 
            mutate(new = new_column)
        colnames(collapsed_window_matrix) <- new_col_names        
    }

    return(collapsed_window_matrix)
}


RLL_windows <- function(slide_run, starting_window, max_windows = 50, coverage = 1) {
    x <- mutate(slide_run, windows = map(data, ~getWindows(.x, starting_window, max_windows, coverage)))
    return(x)   
}

RLL_matrices <- function(maf_file, rll_windows, starting_window, max_windows = 50, coverage = 1) {
    if (!("windows" %in% names(rll_windows))) {
        rll_windows <- RLL_windows(rll_windows, starting_window, max_windows, coverage)
    }
    
    x <- mutate(rll_windows, matrices = pmap(rll_windows, ~getMatrix(maf_file, candidate_panel = ..4, jump_length = ..3)))
    
    return(x)
}

### Functions for making an OLM or random forest out of data

getModel <- function(matrix) {
    
    formula <- matrix %>% 
        select(starts_with("Window")) %>% 
        select(which(colSums(.) > 0)) %>% 
        colnames() %>% 
        paste(collapse = "+") %>% 
        paste("TMB ~", .) %>% 
        as.formula()
    
    fit <- lm(formula, matrix)
    
    return(fit)  
}

get_fModel <- function(matrix) {
    
    formula <- matrix %>% 
        select(starts_with("Window")) %>% 
        select(which(colSums(.) > 0)) %>% 
        colnames() %>% 
        paste(collapse = "+") %>% 
        paste("TMB ~", .) %>% 
        as.formula()
    
    rf.matrix <- randomForest(formula, matrix)
    
    return(rf.matrix) 
}
                                                           
get_svmModel <- function(matrix, type = "eps-regression", kernel = "radial") {
    
    formula <- matrix %>% 
        select(starts_with("Window")) %>% 
        select(which(colSums(.) > 0)) %>% 
        colnames() %>% 
        paste(collapse = "+") %>% 
        paste("TMB ~", .) %>% 
        as.formula()
    
    svm.fit <- svm(formula, matrix)
    
    return(svm.fit)
    
}
                                                           
RLL_models <- function(rll_matrices) {
    return(mutate(rll_matrices, models = map(matrices, getModel)))
}
                                                           
RLL_f_models <- function(rll_matrices) {
    return(mutate(rll_matrices, f_models = map(matrices, get_fModel)))
}
                                                           
RLL_svm_models <- function(rll_matrices) {
    return(mutate(rll_matrices, svm_models = map(matrices, get_svmModel)))
}                                                           

### Functions for validating models

testModel <- function(model, window_matrix, type = "R", threshold = 20) {
    
    comparison <- tibble(prediction = predict(model, window_matrix), actual = window_matrix$TMB)
    
    
    if (type == "AUC") {
        comparison <- mutate(comparison, actual = as.integer(actual >= threshold))
        
        return(calc_auc(ggplot(comparison, aes(d = actual, m = prediction)) + geom_roc())$AUC)
    }
    
    if (type == "Cor") {
        return(cor(comparison$actual, comparison$prediction))
    }
    
    if (type == "R") {
        return(broom::glance(lm(actual ~ prediction, data = comparison))$r.squared)
    }
    
    if (type == "D") {
        return(comparison %>% 
                  mutate(difference2 = (actual - prediction)^2) %>% 
                  pull(difference2) %>% 
                  {sum(.)/length(.)})
    }
    
    if (type == "C" | type == "Cmin" | type == "Con") {
        comparison <- comparison %>% 
            mutate(predicted_tmb_high = prediction >= threshold,
                   actual_tmb_high = actual >= threshold)
        
        high <- comparison %>% 
                    filter(actual_tmb_high == TRUE)
        low <- comparison %>% 
                    filter(actual_tmb_high == FALSE)
        correct_high <- high %>% 
                            filter(predicted_tmb_high == TRUE)
        correct_low <- low %>% 
                            filter(predicted_tmb_high == FALSE)
        
    }
    
    if (type == "C") {
        
        
        out <- list(nrow(correct_high)/nrow(high), nrow(correct_low)/nrow(low))
        names(out) <- c("sensitivity", "specificity")
        
        return(out)
    }
    
    if (type == "Cmin") {

        
        out <- min(nrow(correct_high)/nrow(high), nrow(correct_low)/nrow(low))
        
        
        return(out)
    }
    
    if (type == "Con") {
        
        false_high <- low %>% 
            filter(predicted_tmb_high == TRUE)
        
        false_low <- high %>% 
            filter(predicted_tmb_high == FALSE)

        total <- nrow(comparison)
        out <- tibble(Actual = c("High", "Low"), Predicted_High = c(nrow(correct_high), nrow(false_high))/total,
                     Predicted_Low = c(nrow(false_low), nrow(correct_low))/total)
        
        return(out)
        
    }
    
    if (type == "W") {
        return(comparison)
    }
}
                           
RLL_test_matrices <- function(test_data, rll_models, type = "R", threshold = 20) {
    if (!("models" %in% colnames(rll_models))) {
        rll_models <- RLL_models(rll_models)
    }
    
    rll_test_matrices <- rll_models %>% 
        mutate(test_matrices = map2(windows, jump_length, ~ getMatrix(test_data, .x, .y)))
    
    return(rll_test_matrices)
}
                           
RLL_test <- function(rll_test_matrices, type = "D", threshold = 20, which_model = "OLM") {
    
    if (which_model == "OLM") {
        var_models <- rll_test_matrices$models
    }
    if (which_model == "RF") {
        var_models <- rll_test_matrices$f_models
    }
    if (which_model == "SVM") {
        var_models <- rll_test_matrices$svm_models
    }
    rll_test <- rll_test_matrices %>% 
        mutate(training_stats = as.numeric(map2(var_models, 
                                     rll_test_matrices$matrices, 
                                     ~testModel(.x, .y, type, threshold)))) %>% 
        mutate(test_stats = as.numeric(map2(var_models, 
                                     rll_test_matrices$test_matrices, 
                                     ~testModel(.x, .y, type, threshold))))
    return(rll_test)
}



### Functions to automate the entire RLL procedure, starting from an RLL slide object, all the way to model testing, and to do this across a range of panel sizes
                                                           
                                                           
RLL_analyse_panel_size <- function(rll_run, data, panel_sizes, max_windows = 50, coverage = 1, type = "D", threshold = 20) {
    rll_objects <- NA
    for (size in panel_sizes) {
        message(paste("panel size", size))
        message("making windows")
        rll <- RLL_windows(rll_run, size, max_windows, coverage)
        message("making matrices")
        rll <- RLL_matrices(data[["training_data"]], rll, size, coverage = coverage)
        print(rll$matrices[[2]] %>% 
                 select(starts_with("Window")))
        message("making linear models")
        rll <- RLL_models(rll)
        message("making random forest models")
        rll <- RLL_f_models(rll)
        message("making svm models")
        rll <- RLL_svm_models(rll)
        message("making test matrices")
        rll <- RLL_test_matrices(data[["test_data"]], rll)
        rll$size <- size
        if (is.na(rll_objects)) {
            rll_objects <- rll %>% 
                select(-data)
        }
        else {
            rll_objects <- bind_rows(rll_objects, rll %>% select(-data))
        }
        
    }
    return(rll_objects %>% 
              group_by(size) %>% 
              nest())
}
                                                           
                                                           
RLL_panel_size_test <- function(rll_panel_size_analysis, type = "D", threshold = 20, which_model = "OLM") {
    
    stats <- tibble(size = vector(), iteration = vector(), test_train = character(), stat = vector())
    
    for (n in 1:length(rll_panel_size_analysis$size)) {
        new_stats <- RLL_test(rll_panel_size_analysis$data[[n]], type, threshold, which_model) %>% 
            select(iteration, training_stats, test_stats) %>% 
            gather(key = test_train, value = stat, -iteration)
        new_stats$size <- rll_panel_size_analysis$size[[n]]
        new_stats <- new_stats %>% 
            select(size, iteration, test_train, stat)
        stats <- bind_rows(stats, new_stats)
    }
    
    return(stats)
}
    
### Functions for analysing the number of windows restricted to
                                                           
RLL_analyse_max_windows <- function(rll_run, data, panel_size, max_windows, coverage = 1) {
    rll_objects <- NA
    for (max_window in max_windows) {
        message(paste("max windows:", max_window))
        rll <- RLL_windows(rll_run, panel_size, max_window, coverage)
        
        message("making matrices")
        rll <- RLL_matrices(data[["training_data"]], rll, panel_size, coverage = coverage)
        print(rll$matrices[[2]] %>% 
                 select(starts_with("Window")))
        
        message("making linear models")
        rll <- RLL_models(rll)
        
        message("making random forest models")
        rll <- RLL_f_models(rll)
        
        message("making svm models")
        rll <- RLL_svm_models(rll)
        
        message("making test matrices")
        rll <- RLL_test_matrices(data[["test_data"]], rll)
        
        rll$max_window <- max_window
        
        if (is.na(rll_objects)) {
            rll_objects <- rll %>% 
                select(-data)
        }
        else {
            rll_objects <- bind_rows(rll_objects, rll %>% select(-data))
        }
        
    }
    
    return(rll_objects %>% 
              group_by(max_window) %>% 
              nest())
}
                                                                 
RLL_max_window_test <- function(rll_max_window_analysis, type = "D", threshold = 20, which_model = "OLM") {
    
    stats <- tibble(max_window = vector(), iteration = vector(), test_train = character(), stat = vector())
    
    for (n in 1:length(rll_max_window_analysis$max_window)) {
        new_stats <- RLL_test(rll_max_window_analysis$data[[n]], type, threshold, which_model) %>% 
            select(iteration, training_stats, test_stats) %>% 
            gather(key = test_train, value = stat, -iteration)
        new_stats$max_window <- rll_max_window_analysis$max_window[[n]]
        new_stats <- new_stats %>% 
            select(max_window, iteration, test_train, stat)
        stats <- bind_rows(stats, new_stats)
    }
    
    return(stats)
}                                                           
                                          
### ZLL
                                                          
ZLL_slide <- function(maf_file, starting_window, iterations, zoom, pan_bias, coverage) {
# Compiles a dataframe with iterations in one column and the dataframes giving the
# results of that result of iteration in another. It proceeds like RLL_slide, but 
# at each iteration insists that the loci 'zoomed' onto are significant across a range
# of cancer types
    
    nested_mafs <- maf_file %>% 
        group_by(cancer_type) %>% 
        nest()
    
    nested_mafs <- nested_mafs %>% 
        mutate(tmb_tables = map(data, ~ TMB_Calc(., nonsilent = TRUE)))
    
    window_size <- starting_window
    jump_length <- as.integer(window_size/coverage)
    n_cancer <- length(nested_mafs$cancer_type)
    
    message("Iteration 1")
    nested_mafs <- nested_mafs %>% 
        mutate(full_positions = map2(data, tmb_tables, ~genome_slide(.x, .y, window_size, jump_length)))
    
    nested_mafs$full_positions <- nested_mafs$full_positions %>% 
        map(function(x) x %>% mutate(significance = rank(significance)))
    
    current_iter <- nested_mafs$full_positions[[1]]
    current_iter$iteration <- 1
    

    for (i in 2:n_cancer) {
        current_iter <- left_join(current_iter, nested_mafs$full_positions[[i]], by = c("chromosome", "position", "key"))
    }
     
    current_iter$significance <- current_iter %>% 
        select(starts_with("significance")) %>%
        as.matrix() %>% 
        rowOrderStats(which = n_cancer + 1 - pan_bias)
    current_iter <- current_iter %>% 
        select(iteration, chromosome, position, key, significance)
      
    nested_mafs$full_positions <- map(nested_mafs$cancer_type, function(x) current_iter %>% select(- iteration))
    full_iter <- current_iter
                                      
    for (index in 2:iterations) {
        window_size <- as.integer(window_size/zoom)
        jump_length <- as.integer(jump_length/zoom)
        
        message(paste("Iteration", index))
        nested_mafs <- nested_mafs %>% 
            mutate(full_positions = map2(data, full_positions, ~genome_restricted_slide(.x, .y, zoom)))

        nested_mafs$full_positions <- nested_mafs$full_positions %>% 
            map(function(x) x %>% mutate(significance = rank(significance)))
                
        current_iter <- nested_mafs$full_positions[[1]]
        current_iter$iteration <- index
        for (i in 2:n_cancer) {
            current_iter <- left_join(current_iter, nested_mafs$full_positions[[i]], by = c("chromosome", "position", "key"))
        }
                
        current_iter$significance <- current_iter %>% 
            select(starts_with("significance")) %>%
            as.matrix() %>% 
            rowOrderStats(which = n_cancer + 1 - pan_bias)
                
        current_iter <- current_iter %>% 
            select(iteration, chromosome, position, key, significance) 
                
        full_iter <- bind_rows(full_iter, current_iter)
        
        nested_mafs$full_positions <- map(nested_mafs$cancer_type, function(x) current_iter %>% select(- iteration))
                   
    }
    
    full_iter <- full_iter %>% 
        group_by(iteration) %>% 
        nest()    
    
    full_iter$jump_length <- (starting_window/coverage)/(zoom**(full_iter$iteration - 1))
    
    return(full_iter)
    
}                                                          
  
                                          
### Gene Perspective Functions
                                          
gene_TMB_Calc <- function(data, get = "p", report = FALSE) {  
    
    if (report) {message("Calculating global tmbs")}
    tmb_table <- TMB_Calc(data) %>% 
        select(-study)
    
    if (report) {message("Attaching samplewise data")}
    nested_by_sample <- data %>% 
        group_by(Tumor_Sample_Barcode) %>% 
        nest() %>% 
        ungroup()
    nested_with_tmb <- full_join(nested_by_sample, tmb_table, by = "Tumor_Sample_Barcode")
    
    if (report) {message("Calculating local mutation burdens")}
    nested_gene_calc <- nested_with_tmb %>% 
        mutate(gene_mbs = map(data, function (data) count(data, Hugo_Symbol))) %>%
        select(-data) %>% 
        unnest()
    
    if (report) {message("Compiling gene-wise local vs global tmbs")}
    by_gene_tmb_vs_lmb <- nested_gene_calc %>% 
        group_by(Hugo_Symbol) %>% 
        nest() %>% 
        mutate(data = map(data, function(data) full_join(tmb_table, data, by = c("Tumor_Sample_Barcode", "TMB")) %>% 
                                                  mutate(n = replace_na(n, 0))))
    
    if ("p" %in% get) {
        if (report) {message("Computing p_values")}
        by_gene_tmb_vs_lmb <- by_gene_tmb_vs_lmb %>% 
            mutate(model = map(data, function(data) summary(lm(TMB ~ n, data = data))$coefficients)) %>% 
            mutate(coefficient = map(model, function(model) model[2,1])) %>% 
            mutate(p_val = map(model, function(model) model[2,4])) %>% 
            select(-model) %>%   
            mutate(coefficient = unlist(coefficient),
                   p_val = p.adjust(unlist(p_val), method = "BH")) 
    }
                               
    if ("c" %in% get) {
        if (report) {message("Computing correlations")} 
        by_gene_tmb_vs_lmb <- by_gene_tmb_vs_lmb %>% 
            mutate(cor = map(data, function(data) cor(data$TMB, data$n))) %>% 
            mutate(cor = unlist(cor))
      
    }
                            
    return(by_gene_tmb_vs_lmb)
}
                             
get_gene_stats <- function(gene_data) {
    return(gene_data %>%
                select(-data) %>% 
                mutate(coefficient_rank = rank(coefficient)) %>% 
                mutate(p_val_rank = nrow(gene_data) + 1 - rank(p_val)))
}
                           
by_cancer_gene_stats <- function(maf_file, pan_bias = NULL, pivot = "p_val_rank", report = FALSE) {
    
    nested_mafs <- maf_file %>% 
        group_by(cancer_type) %>% 
        nest()
    
    n_cancer <- length(nested_mafs$cancer_type)
    
    if (is.null(pan_bias)) {
        pan_bias <- n_cancer
    }
    
    nested_mafs <- nested_mafs %>% 
        mutate(gene_stats = map(data, ~gene_TMB_Calc(.x, report = report) %>% get_gene_stats()))
    
    output_stats <- nested_mafs$gene_stats[[1]]
    
    for (i in 2:n_cancer) {
        output_stats <- full_join(output_stats, nested_mafs$gene_stats[[i]], by = c("Hugo_Symbol"))
    
    }
    
    output_stats[is.na(output_stats)] <- 0
   
    output_stats[[pivot]] <- output_stats %>% 
        select(starts_with(pivot)) %>% 
        as.matrix() %>%     
        rowOrderStats(which = n_cancer + 1 - pan_bias)
    output <- output_stats %>% 
        select(Hugo_Symbol)
    
    output[[pivot]] <- output_stats[[pivot]]
    output_2 <- nested_mafs %>%
        select(cancer_type, gene_stats)
    
    return(list(output, output_2))
    
}
                           
get_gene_matrix <- function(data, gene_list, report = FALSE) {
    
    tmb_table <- TMB_Calc(data) %>%
        select(-study)
    
    if (length(gene_list) == 0) {
        return(tmb_table)
    }
    
    data <- data %>% 
        filter(Hugo_Symbol %in% gene_list)
    
    extra_genes <- setdiff(gene_list, what_genes(data))
    
    if (report) {message("Attaching samplewise data")}
    nested_by_sample <- data %>% 
        group_by(Tumor_Sample_Barcode) %>% 
        nest() %>% 
        ungroup()
  
    if (report) {message("Calculating local mutation burdens")}
    nested_gene_calc <- nested_by_sample %>% 
        mutate(gene_mbs = map(data, function(data) count(data, Hugo_Symbol))) %>%
        select(-data) %>% 
        unnest() %>% 
        spread(key = Hugo_Symbol, value = n)
                              
    if (report) {message("Attaching global burdens")}
    nested_with_tmbs <- full_join(tmb_table, nested_gene_calc, by = "Tumor_Sample_Barcode")  
    nested_with_tmbs[is.na(nested_with_tmbs)] <- 0
                              
    if (report) {message("Attaching missing genes")}
    for (gene in extra_genes) {
        nested_with_tmbs[[gene]] <- 0
    }
                              
    return(nested_with_tmbs)
}
                              
what_genes <- function(data) {
    gene_list <- data %>% 
        pull(Hugo_Symbol) %>% 
        unique()
    
    return(gene_list)
}
                              
by_cancer_test <- function(model, data, genes, type = "R", threshold = 20) {
    training_data <- data[["training_data"]] %>% 
        group_by(cancer_type) %>% 
        nest()
    
    test_data <- data[["test_data"]] %>% 
        group_by(cancer_type) %>% 
        nest()
    
    training_data <- training_data %>%
        mutate(data = map(data, ~get_gene_matrix(.x, gene_list = genes))) %>% 
        mutate(stats = map(data, ~testModel(model, .x, type, threshold))) %>% 
        select(-data) %>% 
        mutate(test_train = "training_data")
    
    test_data <- test_data %>% 
        mutate(data = map(data, ~get_gene_matrix(.x, gene_list = genes))) %>%
        mutate(stats = map(data, ~testModel(model, .x, type, threshold))) %>% 
        select(-data) %>% 
        mutate(test_train = "test_data")
    
    return(bind_rows(training_data, test_data))    
    
} 
                              
get_gene_model <- function(model_genes, data, matrix = NULL) {
    if (is.null(matrix)) {
        matrix <- get_gene_matrix(data, model_genes) %>%
            ungroup() %>% 
            select(-Tumor_Sample_Barcode)
        }
        
    else {
        matrix <- matrix %>% 
            ungroup() %>% 
            select(-Tumor_Sample_Barcode)
    }
        
    fit <- lm(TMB ~ ., data = matrix) 
    return(fit)
    
}
                              
get_gene_f_model <- function(model_genes, data, matrix = NULL) {
    if (is.null(matrix)) {
        matrix <- get_gene_matrix(data, model_genes) %>%
            ungroup() %>% 
            select(-Tumor_Sample_Barcode)
        }
    else {
        matrix <- matrix %>% 
            ungroup() %>% 
            select(-Tumor_Sample_Barcode)
    }
   
    fit <- randomForest(TMB ~ ., data = matrix) 
    return(fit)
}
                              
get_gene_svm_model <- function(model_genes, data, matrix = NULL) {
    if (is.null(matrix)) {
        matrix <- get_gene_matrix(data, model_genes) %>%
            ungroup() %>% 
            select(-Tumor_Sample_Barcode)
        }
    else {
        matrix <- matrix %>% 
            ungroup() %>% 
            select(-Tumor_Sample_Barcode)
    }
   
    fit <- svm(TMB ~ ., data = matrix, kernel = "radial") 
    return(fit)
}
                              
get_model_stats <- function(model_genes, data) {
    matrix <- get_gene_matrix(data, model_genes) %>%
        ungroup() %>% 
        select(-Tumor_Sample_Barcode)
   
    fit <- lm(TMB ~ ., data = matrix) 
    return(broom::glance(fit)$AIC)
    
}
                              
iter_models <- function(iters, data, gene_list = NULL) {
    if (is.null(gene_list)){
        gene_list <- what_genes(data)
    } 
    model_genes <- c()
    
    for (iter in 1:iters) {
        message(iter)
        new_models <- map(gene_list, ~ get_gene_model(c(model_genes, .x), data))
        new_gene <- gene_list[which(new_models == min(unlist(new_models)))]
        
        model_genes <- c(model_genes, new_gene)
    }

   return(model_genes)     
    
}  
                              
analyse_gene_panel_size <- function(sizes, gene_stats, data, test_type, by_cancer = FALSE, threshold = 20) {
    
    stats <- tibble(Lin = rep(NA, length(sizes)), RF = rep(NA, length(sizes)), SVM = rep(NA, length(sizes)))
    
    if (test_type == "C") {
        stats <- tibble(Lin = rep(NA, 2*length(sizes)), RF = rep(NA, 2*length(sizes)), SVM = rep(NA, 2*length(sizes)), spec_sens = rep(NA, 2*length(sizes)))
    }
    
    for (i in 1:length(sizes)) {
        size <- sizes[i]
        message(paste("Panel size", size))
        
        genes <- gene_stats %>% 
            arrange(desc(p_val_rank)) %>% 
            pull(Hugo_Symbol) %>% 
            {.[1:size]}
        message("making models")
        message("linear")
        lin_model <- get_gene_model(genes, data[["training_data"]])
        message("random forest")    
        rf_model <- get_gene_f_model(genes, data[["training_data"]])
        message("svm")
        svm_model <- get_gene_svm_model(genes, data[["training_data"]])
        
        test_matrix <- get_gene_matrix(data[["test_data"]], genes)
        message("testing models")
        lin_test <- testModel(lin_model, test_matrix, type = test_type, threshold = threshold)
        rf_test <- testModel(rf_model, test_matrix, type = test_type, threshold = threshold)
        svm_test <- testModel(svm_model, test_matrix, type = test_type, threshold = threshold)
        
        if (test_type != "C") {
            stats[i, "Lin"] <- lin_test
            stats[i,"RF"] <- rf_test
            stats[i, "SVM"] <- svm_test
        }
        if (test_type == "C") {
            
            stats[i, "Lin"] <- lin_test$sensitivity; stats[i + length(sizes), "Lin"] <- lin_test$specificity
            stats[i, "RF"] <- rf_test$sensitivity; stats[i + length(sizes), "RF"] <- rf_test$specificity
            stats[i, "SVM"] <- svm_test$sensitivity; stats[i + length(sizes), "SVM"] <- svm_test$specificity
            stats$spec_sens[i] <- "sensitivity"
            stats$spec_sens[i + length(sizes)] <- "specificity"
        }
    }
    if (test_type == "C") {
        stats <- stats %>% 
            gather(model_type, stat, -spec_sens) %>% 
            mutate(panel_size = rep(sizes, 6))
    }
    else {
        stats <- stats %>% 
            gather(model_type, stat) %>% 
            mutate(panel_size = rep(sizes, 3))
    }
    return(stats)
    
}   
                              
method_p <- function(p_val, coefficient, cor, n, length) {
    return(-log(p_val))
}
method_p_over_length <- function(p_val, coefficient, cor, n, length) {
    return(-log(p_val)/length)
}
method_cor <- function(p_val, coefficient, cor, n, length) {
    return(cor)
}
method_cor_over_length <- function(p_val, coefficient, cor, n, length) {
    return(cor/length)
}
method_cor_over_sqrt_length <- function(p_val, coefficient, cor, n, length) {
    return(cor/sqrt(length))
}
method_cor_length_n <-  function(p_val, coefficient, cor, n, length) {
    return(cor*n/length**1.5)
}
                             
                              
get_gene_panel_for_size <- function(cancer_stats, method, size) {
    
    cancer_stats <- cancer_stats %>% 
        arrange(desc(method(p_val, coefficient, cor, n, length)))
    
    gene_panel <- list()
    
    if (cancer_stats$length[1] > size) {
        message("Size to small for any panel with this method")
        return(gene_panel)
    }   
    
    else {
        panel_size <- cancer_stats$length[1]
        gene_panel <- c(gene_panel, cancer_stats$Hugo_Symbol[1])
        i <- 2
        continue  <- TRUE
    }
    
    while (continue) {
        if (panel_size + cancer_stats$length[i] <= size) {
            panel_size <- panel_size + cancer_stats$length[i]
            gene_panel <- c(gene_panel, cancer_stats$Hugo_Symbol[i])
            i <- i + 1
        }
        else {
            continue = FALSE
        }
    }
    return(gene_panel)
}                              
                              
analyse_gene_panel_lengths <- function(data, lengths, method, cancer_stats, threshold = 20, type = "C") {
    
    N <- length(lengths)
    print(N)
    
    if (type == "C") {
    output <- tibble(lengths = rep(lengths, 6), results = rep(NA, 6*N), 
                     spec_sens = rep(c("sensitivity", "specificity"), 3, each = N), 
                     model_type = rep(c("linear", "random_forest", "svm"), each = 2*N))
    }
    else {
        output <- tibble(lengths = rep(lengths, 3), results = rep(NA, 3*N), 
                        model_type = rep(c("linear", "random_forest", "svm"), each = N))
    }
    
    for (i in 1:N) {
        message(i)
        
        length <- lengths[i]
        gene_panel <- get_gene_panel_for_size(cancer_stats, method, length)

        lin_mod <- get_gene_model(gene_panel, data[["training_data"]])
        rf_mod <- get_gene_f_model(gene_panel, data[["training_data"]])
        svm_mod <- get_gene_svm_model(gene_panel, data[["training_data"]])
        
        lin_test <- testModel(lin_mod, get_gene_matrix(data[["test_data"]], gene_panel), threshold = threshold, type = type)
        rf_test <- testModel(rf_mod, get_gene_matrix(data[["test_data"]], gene_panel), threshold = threshold, type = type)
        svm_test <- testModel(svm_mod, get_gene_matrix(data[["test_data"]], gene_panel), threshold = threshold, type = type)
        
        if (type == "C") {
        output$results[i] <- lin_test$sensitivity
        output$results[i + N] <- lin_test$specificity
        output$results[i + 2*N] <- rf_test$sensitivity
        output$results[i + 3*N] <- rf_test$specificity
        output$results[i + 4*N] <- svm_test$sensitivity
        output$results[i + 5*N] <- svm_test$specificity
    
        }
        else {
            output$results[i] <- lin_test
            output$results[i + N]  <- rf_test
            output$results[i + 2*N] <- svm_test
        }
    }
    
    return(output)
}     
                              
balance_data <- function(data, threshold = 20) {
    tmbs <- TMB_Calc(data)
    
    high_tmbs <- tmbs %>% 
        filter(TMB >= threshold)
    
    low_tmbs <- tmbs %>% 
        filter(TMB < threshold)
    
    if (nrow(high_tmbs) <= nrow(low_tmbs)) {
        low_tmbs <- low_tmbs %>% 
            filter(Tumor_Sample_Barcode %in% sample(low_tmbs$Tumor_Sample_Barcode, nrow(high_tmbs)))
    }
    else {
        high_tmbs <- high_tmbs %>% 
              filter(Tumor_Sample_Barcode %in% sample(high_tmbs$Tumor_Sample_Barcode, nrow(low_tmbs)))
    }
    
    chosen_ones <- c(low_tmbs$Tumor_Sample_Barcode, high_tmbs$Tumor_Sample_Barcode)
    
    balanced_data <- data %>% 
              filter(Tumor_Sample_Barcode %in% chosen_ones)
    
    return(balanced_data)
}
                              
get_roc <- function(models, test_data, genes, threshold = 20) {
    
    comparison = tibble(prediction = vector(), actual = vector(), model = character())
    
    test_matrix <- get_gene_matrix(test_data, genes) %>%
            ungroup() %>% 
            select(-Tumor_Sample_Barcode) %>% 
            mutate(TMB = as.numeric(TMB >= threshold))
    
    for (i in 1:length(models)) {
        comparison = bind_rows(comparison, tibble(prediction = predict(models[[i]], test_matrix), actual = test_matrix$TMB, model = paste("model",i)))
    }
    
    return(ggplot(comparison, aes(d = actual, m = prediction, colour = model)) + geom_roc())
}
                 
                              
get_gene_lengths <- function(gene_list, ensembl = ensembl37) {
    
    full_lengths <- getBM(c("hgnc_symbol", "chromosome_name", "start_position", "end_position"), filters = "hgnc_symbol", values = gene_list$hgnc_symbol, mart = ensembl) %>% 
        mutate(length = end_position - start_position) %>% 
        filter(chromosome_name %in% c(1:22, "X", "Y")) %>% 
        select(hgnc_symbol, length)
    
    coding_lengths <- getBM(c("cds_length", "ensembl_gene_id"), filters = "hgnc_symbol", values = gene_list$hgnc_symbol, mart = ensembl) %>% 
        {full_join(., getBM(c("hgnc_symbol", "ensembl_gene_id"), filters = "ensembl_gene_id", values = .$ensembl_gene_id, mart = ensembl), by = "ensembl_gene_id")} %>% 
        group_by(hgnc_symbol) %>% 
        mutate(max_cds = max(cds_length, na.rm = TRUE)) %>% 
        select(hgnc_symbol, max_cds) %>% 
        distinct() %>% 
        mutate(max_cds = if_else(is.finite(max_cds), max_cds, as.double(NA_integer_)))
    
    genome_lengths <- getBM(c("ensembl_gene_id", "genomic_coding_start", "genomic_coding_end"), filters = "hgnc_symbol", values = gene_list$hgnc_symbol, ensembl37) %>%
        {full_join(., getBM(c("hgnc_symbol", "chromosome_name", "ensembl_gene_id"), filters = "ensembl_gene_id", values = .$ensembl_gene_id, mart = ensembl), by = "ensembl_gene_id")} %>%
        filter(chromosome_name %in% c(1:22, "X", "Y")) %>% 
        select(hgnc_symbol,genomic_coding_start, genomic_coding_end) %>% 
        filter(!(is.na(genomic_coding_start)|is.na(genomic_coding_end))) %>% 
        group_by(hgnc_symbol) %>% 
        nest() %>% 
        mutate(data = map(data, function(data) data %>% 
                  pmap(function(genomic_coding_start, genomic_coding_end) genomic_coding_start:genomic_coding_end) %>% 
                  unlist() %>% 
                  unique() %>% 
                  length())) %>% 
        mutate(genome_length = unlist(data)) %>% 
        select(hgnc_symbol, genome_length)
    
    
    return(full_join(full_lengths, coding_lengths, by = "hgnc_symbol") %>% 
              full_join(genome_lengths, by = "hgnc_symbol"))
        
}
               
get_chr_bed <- function(chromosome_positions) {
    chromosome_positions <- chromosome_positions %>% 
        mutate(backconsec = position - lag(position)) %>% 
        mutate(forconsec = lead(position) - position) %>% 
        mutate(backconsec = is.na(backconsec) | backconsec != 1) %>% 
        mutate(forconsec = is.na(forconsec) | forconsec != 1)
    
    chromStart <- chromosome_positions %>% 
        filter(backconsec) %>% 
        pull(position)
    
    chromEnd <- chromosome_positions %>% 
        filter(forconsec) %>% 
        pull(position)
    
    return(tibble(chromStart, chromEnd))
}
               
get_bed <- function(gene_list, ensembl = ensembl37, by = "genome_length") {
    if (by == "genome_length") {
        all_loci <- getBM(c("chromosome_name", "genomic_coding_start", "genomic_coding_end"), filters = "hgnc_symbol", values = gene_list, mart = ensembl37) %>% 
            filter(!(is.na(genomic_coding_start)|is.na(genomic_coding_end))) %>% 
            pmap(function(chromosome_name, genomic_coding_start, genomic_coding_end) tibble(chrom = rep(paste0("chr", chromosome_name), length(genomic_coding_start:genomic_coding_end)), position = genomic_coding_start:genomic_coding_end)) %>% 
            bind_rows() %>% 
            distinct() %>% 
            filter(chrom %in% paste0("chr", c(1:22, "X", "Y"))) %>% 
            group_by(chrom) %>% 
            nest() %>% 
            arrange(chrom) %>%
            mutate(data = map(data, ~arrange(.x, position))) %>%
            mutate(data = map(data, get_chr_bed)) %>% 
            unnest()
    }
    return(all_loci)
}               