### Functions for Calculating global TMB from whole exome mutation data

abridge <- function(maf_file, nonsilent = TRUE, by_study = FALSE) {
# Takes a maf file and selects the characteristics required to perform TMB analysis
# and removes duplicate entries (which exist for a variety of reasons, consult
# the TCGA website)
# Requires tidyverse
    
    if ("Start_position" %in% colnames(maf_file)) {
        maf_file <- rename(maf_file, Start_Position = Start_position)
    }
    
    if ("End_position" %in% colnames(maf_file)) {
        maf_file <- rename(maf_file, End_Position = End_position)
    }
    
    if (by_study) {
        data_abridged <- maf_file %>% 
            select(Hugo_Symbol, Chromosome, Start_Position, End_Position, Variant_Classification, Variant_Type, Tumor_Sample_Barcode, study) %>% 
            distinct()
    }
    else {
        data_abridged <- maf_file %>% 
            select(Hugo_Symbol, Chromosome, Start_Position, End_Position, Variant_Classification, Variant_Type, Tumor_Sample_Barcode) %>% 
            distinct()   
    }

    if (nonsilent == TRUE) {
        data_abridged <- data_abridged %>% 
            filter(Variant_Classification %in% c('Frame_Shift_Del', 'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins', 'Missense_Mutation', 'Nonsense_Mutation', 'Nonstop_Mutation', 'Splice_Site', 'Translation_Start_Site'))
              }
    return(data_abridged)
}


cbio_getData <- function(path_name, cancer_type, by_cancer = FALSE, test = TRUE, training = 0.7, nonsilent = TRUE) {
    
    data <- tibble(Hugo_Symbol = character(), Chromosome = character(), 
                                 Start_Position = vector(), End_Position = vector(), 
                                 Variant_Classification = character(), Variant_Type = character(), 
                                 Tumor_Sample_Barcode = character(), study = character())
    
    for (i in 1:length(dir(path_name))) {
        
        if ("data_mutations_extended.txt" %in% dir(paste0(path_name, "/", dir(path_name)[i]))) {
            study_meta <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/meta_study.txt"), col_names = FALSE, comment = "#")
            cancer <- substr(study_meta[1,],17,nchar((study_meta[1,])))
            
            if (cancer %in% cancer_type) {
                print(dir(path_name)[i])
                new_data <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/data_mutations_extended.txt"), comment = "#") 
                if (all(substr(new_data$Chromosome, 1, 3) == "chr")) {
                    new_data$Chromosome <- substr(new_data$Chromosome, 4, 6)
                }
                if (all(!is.na(new_data$Chromosome))) {
                    new_data <- abridge(new_data, nonsilent)
                    print(new_data %>% 
                             count(Tumor_Sample_Barcode) %>% 
                             nrow())
                    new_data$Tumor_Sample_Barcode <- as.character(new_data$Tumor_Sample_Barcode) 
                    new_data$Chromosome <- as.character(new_data$Chromosome)

                    if (nrow(new_data) > 0) {
                        new_data$study <- dir(path_name)[i]
                        if (by_cancer) {
                            new_data$cancer_type <- cancer
                        }
                    }
                    data <- bind_rows(data, new_data) 
                }
            }
        }
    }
    print(data %>% 
             count(Tumor_Sample_Barcode) %>% 
             nrow())
    if (test == TRUE) {
        tumor_ids <- unique(data$Tumor_Sample_Barcode)
        
        training_sample <- sample(length(tumor_ids), floor(training*length(tumor_ids)))
        test_sample <- setdiff(1:length(tumor_ids), training_sample)
        print(length(training_sample))
        print(length(test_sample))
        training_ids <- tumor_ids[training_sample]
        test_ids <- tumor_ids[test_sample]
        
        training_data <- data %>% 
            filter(Tumor_Sample_Barcode %in% training_ids)
        test_data <- data %>% 
            filter(Tumor_Sample_Barcode %in% test_ids)
        
        out <- list(training_ids, test_ids, training_data, test_data)
        names(out) <- c("training_ids", "test_ids", "training_data", "test_data")
        return(out)
    }
    else {
        return(data)
    }
}

cbio_getCancerTypes <- function(path_name) {
    cancer_types <- c()
    for (i in 1:length(dir(path_name))) {
        if (!("data_mutations_extended.txt" %in% dir(paste0(path_name, "/", dir(path_name)[i])))) {
            print(paste0("Their is no mutations file in ", dir(path_name)[i]))
        }
        else {
            study_meta <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/meta_study.txt"), col_names = FALSE, comment = "#")
            cancer <- substr(study_meta[1,],17,nchar((study_meta[1,])))
            cancer_types <- unique(c(cancer_types, cancer))
        }
    }
    return(cancer_types)
}

cbio_getDataSets <- function(path_name, cancer_type) {
    data_sets <- c()
    
    for (i in 1:length(dir(path_name))) {
        if (!("data_mutations_extended.txt" %in% dir(paste0(path_name, "/", dir(path_name)[i])))) {
        print(paste0("Their is no mutations file in ", dir(path_name)[i]))
        }
        else {
            study_meta <- read_tsv(paste0(path_name, "/", dir(path_name)[i], "/meta_study.txt"), col_names = FALSE, comment = "#")
            cancer <- substr(study_meta[1,],17,nchar((study_meta[1,])))
            if (cancer == cancer_type) {
                data_sets <- c(data_sets, dir(path_name)[i])
            }
        }
    }
    return(data_sets)
}

TMB_Calc <- function(maf_file, nonsilent = TRUE) {
# Takes a maf file and outputs a table with tumor sample barcode and TMB value
# Requires tidyverse to be installed
# Depends on previous function 'abridge()'
    
    if ("study" %in% colnames(maf_file)) {
        tmb_table <-  maf_file %>%  
                abridge(nonsilent = nonsilent, by_study = TRUE) %>% 
                group_by(Tumor_Sample_Barcode, study) %>% 
                summarise(TMB = n()/30)
        }
    else {
        tmb_table <-  maf_file %>%  
                abridge(nonsilent = nonsilent) %>% 
                group_by(Tumor_Sample_Barcode) %>% 
                summarise(TMB = n()/30)     
    }
    
    return(tmb_table)
}


### Functions for calculating association local vs global for a given window 

Local_TMB_Calc <- function(maf_file, Chrom, Start, Window_Size, ns = FALSE, pre_abridged = FALSE) {
# takes a maf file and outputs a table with tumor sample barcode and local TMB 
# value for the window specified via chromosome, start position and window size
# requires tidyverse to be installed
# requires function 'abridge()'
    
    all_samples <- tibble(Tumor_Sample_Barcode = unique(maf_file$Tumor_Sample_Barcode))
    
    if (pre_abridged == FALSE) {
        maf_file <- abridge(maf_file, nonsilent = ns)
    }
    
    local_tmb_table  <- maf_file %>% 
        filter(Chromosome == Chrom) %>% 
        filter(Start_Position %in% (Start + 0:(Window_Size-1))) %>% 
        group_by(Tumor_Sample_Barcode) %>% 
        summarise(Local_TMB = n())
    
    local_tmb_table <- full_join(all_samples, local_tmb_table, by = "Tumor_Sample_Barcode")
    local_tmb_table[is.na(local_tmb_table)] <- 0
    
    return(local_tmb_table)
}

getPs <- function(local_tmb_table, global_tmb_table) {
# Takes a local tmb table and a global tmb table and returns the significance of their correlation
# Not currently set up to account for multiple testing
# Requires tidyverse
    
    comparison_table <- inner_join(local_tmb_table, global_tmb_table,
           by = "Tumor_Sample_Barcode") 
    #creates a table with Tumor sample barcode, global burden and local burden
    
    if (sum(comparison_table$Local_TMB != 0) > 0) {
    return(summary(lm(TMB~Local_TMB, comparison_table))$coefficients[2,4])
        }
    else {
        return(1)
    }
}

### Functions for a first pass window algorithm


chromosome_slide <- function(maf_file, global_tmb_table = NULL, Chromosome, window_size, jump_length, ns = FALSE) {
# performs a sliding window algorithm on one chromosome
# outputs a vector of significances
# can be given a global tmb table, otherwise will calculate itself
# requires a genome to be loaded under name 'genome', ideally GChr37
# requires packages tidyverse, BSGenome and functions abridge, TMB_Calc, Local_TMB_Calc and getSignificance 
    
# NOTE there's a weird thing going on at the moment where "global_tmb_table = NULL" must be explicitly fed 
# to the function, else it doesn't work
    
    chromosomes <- c(1:22, "X", "Y")
    
    if (is.null(global_tmb_table)) {
        global_tmb_table <- TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    chromosome_length <- length(genome[[which(chromosomes == Chromosome)]])
    position_vector <- seq(from = 1, to = chromosome_length - window_size, by = jump_length)
    len <- length(position_vector)
    key_vector <- (1:len)/len
    chromosome_vector <- rep(Chromosome, len)
    p_vector <- map_dbl(position_vector, ~Local_TMB_Calc(maf_file, Chrom = Chromosome, Start = .x, Window_Size = window_size, pre_abridged = TRUE) %>% 
                                                      getPs(global_tmb_table))
    significance_vector <- -log(p.adjust(p_vector, method = "BH"))
    return(tibble(chromosome = chromosome_vector, position = position_vector, key = key_vector, significance = significance_vector))
    
}

genome_slide <- function(maf_file, global_tmb_table = NULL, window_size, jump_length, ns = FALSE) {
    chromosomes <- c(1:22,"X","Y")
    genome <- BSgenome.Hsapiens.UCSC.hg19
    if (is.null(global_tmb_table)) {
        global_tmb_table = TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    genome_association <- tibble(chromosome = character(), position = vector(), key = vector(), significance = vector())
    
    
    for (n in 1:24) {
        message(chromosomes[n])
        genome_association <- bind_rows(genome_association, chromosome_slide(maf_file, global_tmb_table, chromosomes[n], window_size, jump_length))   
    }
    
    return(genome_association)
    
}


chromosome_restricted_slide <- function(maf_file, previous_run, zoom = 10, global_tmb_table = NULL, Chromosome, ns = FALSE, coverage = 10) {

 
    chromosomes <- c(1:22, "X", "Y")
    
    old_jump_length <- as.numeric(previous_run[2,"position"] - previous_run[1,"position"])
    
    new_jump_length <- max(1,floor(old_jump_length/zoom))
    new_window_size <- coverage*new_jump_length
    
    quant <- 1 - 1/zoom
    
    significant_positions <- previous_run %>% 
        filter(significance > quantile(significance, quant)) %>% 
        filter(chromosome == Chromosome)  
        
    
    chromosome_positions <- c()
    for (position in significant_positions$position) {
        chromosome_positions <- c(chromosome_positions, seq(from = position, to = position + old_jump_length - new_jump_length, by = new_jump_length))
    }
    
    if (is.null(global_tmb_table)) {
        global_tmb_table <- TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    len <- length(chromosome_positions)
    chromosome_vector <- rep(Chromosome, len)
    key_vector <- (1:len)/len
    p_vector <- map_dbl(chromosome_positions, ~Local_TMB_Calc(maf_file, Chrom = Chromosome, Start = .x, Window_Size = new_window_size, pre_abridged = TRUE) %>% 
                                                              getPs(global_tmb_table))
    
    significance_vector <- -log(p.adjust(p_vector, method = "BH"))
    if (len > 0) {
        return(tibble(chromosome = chromosome_vector, position = chromosome_positions, key = key_vector, significance = significance_vector))
    }
    else {
        return(tibble(chromosome = character(), position = vector(), key = vector(), significance = vector()))
    } 
    
}


genome_restricted_slide <- function(maf_file, previous_run, zoom = 10, global_tmb_table = NULL, ns = FALSE, coverage = 1) {
   
    chromosomes <- c(1:22,"X","Y")
    
    if (is.null(global_tmb_table)) {
        global_tmb_table = TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    genome_association <- tibble(chromosome = character(), position = vector(), key = vector(), significance = vector())
    
    
    for (n in 1:24) {
        message(chromosomes[n])
        genome_association <- bind_rows(genome_association, chromosome_restricted_slide(maf_file, previous_run, zoom, global_tmb_table, Chromosome = chromosomes[n], ns, coverage))   
       
    }
    
    return(genome_association)
    
}
    
RLL_slide <- function(maf_file, starting_window, iterations, zoom, coverage) {
# Compiles a dataframe with iterations in one column and the dataframes giving the
# results of that result of iteration in another
    
    global_tmb_table <- TMB_Calc(maf_file, nonsilent = TRUE)
    
    window_size <- starting_window
    jump_length <- as.integer(window_size/coverage)
    message("Iteration 1")
    full_positions <- genome_slide(maf_file, global_tmb_table, window_size, jump_length)
    
    full_positions$iteration <- rep(1, nrow(full_positions))
    old_positions <- full_positions
    
    for (index in 2:iterations) {
        window_size <- as.integer(window_size/zoom)
        jump_length <- as.integer(jump_length/zoom)
        message(paste("Iteration", index))
        new_positions <- genome_restricted_slide(maf_file, old_positions, zoom, global_tmb_table, coverage = coverage)
        new_positions$iteration <- rep(index, nrow(new_positions))
        
        full_positions <- bind_rows(full_positions, new_positions)
        old_positions <- new_positions
    }
    
    full_positions <- full_positions %>% 
        group_by(iteration) %>% 
        nest()    
    
    full_positions$jump_length <- (starting_window/coverage)/(zoom**(full_positions$iteration - 1))
    
    return(full_positions)
    
}
    

### Functions for producing a training matrix

getWindows <- function(window_run, panel_size, max_windows = 50, coverage = 1) {
    
    chromosomes <- c(1:22, "X", "Y")
    working_panel <- tibble(chromosome = factor(character(), levels = chromosomes), position = vector())
    jump_length <- (window_run[2,"position"] - window_run[1, "position"])[1,1]
   
    window_size <- coverage*jump_length
    adding <- TRUE
    
    while (adding) {
        new_position <- window_run %>% 
            filter(significance == max(significance)) %>% 
            filter(chromosome == min(chromosome)) %>% 
            filter(position == min(position)) %>% 
            select(chromosome, position)
        
        if (nrow(working_panel %>% 
            add_row(chromosome = rep(new_position$chromosome[1], coverage), position = new_position$position[1] + jump_length*(0:(coverage-1))) %>% 
            distinct())*jump_length <= panel_size) {
            
            working_panel <- working_panel %>% 
                add_row(chromosome = rep(new_position$chromosome[1], coverage), position = new_position$position[1] + jump_length*(0:(coverage-1))) %>% 
                distinct() %>% 
                group_by(chromosome) %>% 
                arrange(position, .by_group = TRUE) %>% 
                ungroup()
            
        
            window_run <- window_run %>% 
                filter((chromosome != new_position$chromosome)|(position != new_position$position))
        }
        else {
            adding <- FALSE
        }
    }
    
    nonadj_working_panel <- working_panel %>% 
        mutate(seq_id = cumsum(c(1,diff(position)) != jump_length)) %>% 
        group_by(seq_id) %>% 
        nest() %>% 
        mutate(chromosome = map(data, function(data) data$chromosome[1]), 
               position = map(data, function(data) data$position[1]), 
               jumps = map(data, function(data) nrow(data))) %>% 
        select(-c(seq_id, data)) %>% 
        unnest()
          
    n_windows <- nrow(nonadj_working_panel) 
    nonadj_working_panel$cluster <- 1:n_windows       
    set.seed(2019)
                           
    if (n_windows > max_windows) {
        nonadj_working_panel$cluster <- (tibble(x = unlist(map(nonadj_working_panel$chromosome, function(x) which(chromosomes == x)))*10**9, y = nonadj_working_panel$position) %>% 
            kmeans(max_windows))$cluster
    }
    
    return(nonadj_working_panel)
}
                                                           
collapse_col <- function(df, n) {
  
    cols <- setdiff(str_subset(colnames(df), paste0("Window_", n)), str_subset(colnames(df), paste0(n, "[1234567890]")))
    
    return(df %>% 
              select(cols) %>% 
              rowSums()) 
}                                                           

getMatrix <- function(maf_file, candidate_panel, jump_length, global_tmb_table = NULL, ...) {
    
    if (is.null(global_tmb_table)) {
        global_tmb_table = TMB_Calc(maf_file, nonsilent = TRUE)
    }
    
    window_matrix <- global_tmb_table
    
    for (n in 1:nrow(candidate_panel)) {
        new_column <- maf_file %>% 
            filter(Chromosome == candidate_panel$chromosome[n]) %>% 
            filter(Start_Position %in% (candidate_panel$position[n] + 0:(jump_length*candidate_panel$jumps[n] - 1))) %>%
            group_by(Tumor_Sample_Barcode) %>% 
            summarise(Window = n())
    
        colnames(new_column) <- c("Tumor_Sample_Barcode", paste0("Window_", candidate_panel$cluster[n]))
        window_matrix <- full_join(window_matrix, new_column, by = "Tumor_Sample_Barcode")
        
    }
    
    window_matrix[is.na(window_matrix)]  <- 0
    
    window_matrix <- ungroup(window_matrix)
    
    collapsed_window_matrix <- global_tmb_table %>% 
        ungroup()
    
    for (n in 1:length(unique(candidate_panel$cluster))) {
        new_column <- window_matrix %>% 
            collapse_col(n)
        
        new_col_names <- c(colnames(collapsed_window_matrix), paste0("Window_", n))
        
        collapsed_window_matrix <- collapsed_window_matrix %>% 
            mutate(new = new_column)
        colnames(collapsed_window_matrix) <- new_col_names        
    }

    return(collapsed_window_matrix)
}


RLL_windows <- function(slide_run, starting_window, max_windows = 50, coverage = 1) {
    x <- mutate(slide_run, windows = map(data, ~getWindows(.x, starting_window, max_windows, coverage)))
    return(x)   
}

RLL_matrices <- function(maf_file, rll_windows, starting_window, max_windows = 50, coverage = 1) {
    if (!("windows" %in% names(rll_windows))) {
        rll_windows <- RLL_windows(rll_windows, starting_window, max_windows, coverage)
    }
    
    x <- mutate(rll_windows, matrices = pmap(rll_windows, ~getMatrix(maf_file, candidate_panel = ..4, jump_length = ..3)))
    
    return(x)
}

### Functions for making an OLM or random forest out of data

getModel <- function(matrix) {
    
    formula <- matrix %>% 
        select(starts_with("Window")) %>% 
        select(which(colSums(.) > 0)) %>% 
        colnames() %>% 
        paste(collapse = "+") %>% 
        paste("TMB ~", .) %>% 
        as.formula()
    
    fit <- lm(formula, matrix)
    
    return(fit)  
}

get_fModel <- function(matrix) {
    
    formula <- matrix %>% 
        select(starts_with("Window")) %>% 
        select(which(colSums(.) > 0)) %>% 
        colnames() %>% 
        paste(collapse = "+") %>% 
        paste("TMB ~", .) %>% 
        as.formula()
    
    rf.matrix <- randomForest(formula, matrix, ntree = 200)
    
    return(rf.matrix) 
}
                                                           
RLL_models <- function(rll_matrices) {
    return(mutate(rll_matrices, models = map(matrices, getModel)))
}
                                                           
RLL_f_models <- function(rll_matrices) {
    return(mutate(rll_matrices, f_models = map(matrices, get_fModel)))
}

### Functions for validating models

testModel <- function(model, window_matrix, type = "R", threshold = 20) {
    comparison <- tibble(prediction = predict(model, window_matrix), actual = window_matrix$TMB)
    
    if (type == "R") {
        return(broom::glance(lm(actual~prediction, comparison))$r.squared)
    }
    
    if (type == "D") {
        return(comparison %>% 
                  mutate(difference2 = (actual - prediction)^2) %>% 
                  pull(difference2) %>% 
                  {sum(.)/length(.)})
    }
    
    if (type == "C") {
        comparison <- comparison %>% 
            mutate(predicted_tmb_high = prediction >= threshold,
                   actual_tmb_high = actual >= threshold)
        
        high <- comparison %>% 
                    filter(actual_tmb_high == TRUE)
        low <- comparison %>% 
                    filter(actual_tmb_high == FALSE)
        correct_high <- high %>% 
                            filter(predicted_tmb_high == TRUE)
        correct_low <- low %>% 
                            filter(predicted_tmb_high == FALSE)
        
        out <- list(nrow(correct_high)/nrow(high), nrow(correct_low)/nrow(low))
        names(out) <- c("sensitivity", "specificity")
        
        return(out)
    }
    
    if (type == "Cmin") {
        comparison <- comparison %>% 
            mutate(predicted_tmb_high = prediction >= threshold,
                   actual_tmb_high = actual >= threshold)
        
        high <- comparison %>% 
                    filter(actual_tmb_high == TRUE)
        low <- comparison %>% 
                    filter(actual_tmb_high == FALSE)
        correct_high <- high %>% 
                            filter(predicted_tmb_high == TRUE)
        correct_low <- low %>% 
                            filter(predicted_tmb_high == FALSE)
        
        out <- min(nrow(correct_high)/nrow(high), nrow(correct_low)/nrow(low))
        
        
        return(out)
    }
    
    if (type == "W") {
        return(comparison)
    }
}
                           
RLL_test_matrices <- function(test_data, rll_models, type = "R", threshold = 20) {
    if (!("models" %in% colnames(rll_models))) {
        rll_models <- RLL_models(rll_models)
    }
    
    rll_test_matrices <- rll_models %>% 
        mutate(test_matrices = map2(windows, jump_length, ~ getMatrix(test_data, .x, .y)))
    
    return(rll_test_matrices)
}
                           
RLL_test <- function(rll_test_matrices, type = "D", threshold = 20, which_model = "OLM") {
    
    if (which_model == "OLM") {
        var_models <- rll_test_matrices$models
    }
    if (which_model == "RF") {
        var_models <- rll_test_matrices$f_models
    }
    rll_test <- rll_test_matrices %>% 
        mutate(training_stats = as.numeric(map2(var_models, 
                                     rll_test_matrices$matrices, 
                                     ~testModel(.x, .y, type, threshold)))) %>% 
        mutate(test_stats = as.numeric(map2(var_models, 
                                     rll_test_matrices$test_matrices, 
                                     ~testModel(.x, .y, type, threshold))))
    return(rll_test)
}



### Functions to automate the entire RLL procedure, starting from an RLL slide object, all the way to model testing, and to do this across a range of panel sizes
                                                           
                                                           
RLL_analyse_panel_size <- function(rll_run, data, panel_sizes, max_windows = 50, coverage = 1, type = "D", threshold = 20) {
    rll_objects <- NA
    for (size in panel_sizes) {
        message(paste("panel size", size))
        message("making windows")
        rll <- RLL_windows(rll_run, size, max_windows, coverage)
        message("making matrices")
        rll <- RLL_matrices(data[["training_data"]], rll, size, coverage = coverage)
        print(rll$matrices[[2]] %>% 
                 select(starts_with("Window")))
        message("making linear models")
        rll <- RLL_models(rll)
        message("making random forest models")
        rll <- RLL_f_models(rll)
        message("making test matrices")
        rll <- RLL_test_matrices(data[["test_data"]], rll)
        rll$size <- size
        if (is.na(rll_objects)) {
            rll_objects <- rll %>% 
                select(-data)
        }
        else {
            rll_objects <- bind_rows(rll_objects, rll %>% select(-data))
        }
        
    }
    return(rll_objects %>% 
              group_by(size) %>% 
              nest())
}
                                                           
                                                           
RLL_panel_size_test <- function(rll_panel_size_analysis, type = "D", threshold = 20, which_model = "OLM") {
    
    stats <- tibble(size = vector(), iteration = vector(), test_train = character(), stat = vector())
    
    for (n in 1:length(rll_panel_size_analysis$size)) {
        new_stats <- RLL_test(rll_panel_size_analysis$data[[n]], type, threshold, which_model) %>% 
            select(iteration, training_stats, test_stats) %>% 
            gather(key = test_train, value = stat, -iteration)
        new_stats$size <- rll_panel_size_analysis$size[[n]]
        new_stats <- new_stats %>% 
            select(size, iteration, test_train, stat)
        stats <- bind_rows(stats, new_stats)
    }
    
    return(stats)
}
                                                           
### ZLL
                                                          
ZLL_slide <- function(maf_file, starting_window, iterations, zoom, pan_bias, coverage) {
# Compiles a dataframe with iterations in one column and the dataframes giving the
# results of that result of iteration in another. It proceeds like RLL_slide, but 
# at each iteration insists that the loci 'zoomed' onto are significant across a range
# of cancer types
    
    nested_mafs <- maf_file %>% 
        group_by(cancer_type) %>% 
        nest()
    
    nested_mafs <- nested_mafs %>% 
        mutate(tmb_tables = map(data, ~ TMB_Calc(., nonsilent = TRUE)))
    
    window_size <- starting_window
    jump_length <- as.integer(window_size/coverage)
    n_cancer <- length(nested_mafs$cancer_type)
    
    message("Iteration 1")
    nested_mafs <- nested_mafs %>% 
        mutate(full_positions = map2(data, tmb_tables, ~genome_slide(.x, .y, window_size, jump_length)))
    
    nested_mafs$full_positions <- nested_mafs$full_positions %>% 
        map(function(x) x %>% mutate(significance = rank(significance)))
    
    current_iter <- nested_mafs$full_positions[[1]]
    current_iter$iteration <- 1
    

    for (i in 2:n_cancer) {
        current_iter <- left_join(current_iter, nested_mafs$full_positions[[i]], by = c("chromosome", "position", "key"))
    }
     
    current_iter$significance <- current_iter %>% 
        select(starts_with("significance")) %>%
        as.matrix() %>% 
        rowOrderStats(which = n_cancer + 1 - pan_bias)
    current_iter <- current_iter %>% 
        select(iteration, chromosome, position, key, significance)
      
    nested_mafs$full_positions <- map(nested_mafs$cancer_type, function(x) current_iter %>% select(- iteration))
    full_iter <- current_iter
                                      
    for (index in 2:iterations) {
        window_size <- as.integer(window_size/zoom)
        jump_length <- as.integer(jump_length/zoom)
        
        message(paste("Iteration", index))
        nested_mafs <- nested_mafs %>% 
            mutate(full_positions = map2(data, full_positions, ~genome_restricted_slide(.x, .y, zoom)))

        nested_mafs$full_positions <- nested_mafs$full_positions %>% 
            map(function(x) x %>% mutate(significance = rank(significance)))
                
        current_iter <- nested_mafs$full_positions[[1]]
        current_iter$iteration <- index
        for (i in 2:n_cancer) {
            current_iter <- left_join(current_iter, nested_mafs$full_positions[[i]], by = c("chromosome", "position", "key"))
        }
                
        current_iter$significance <- current_iter %>% 
            select(starts_with("significance")) %>%
            as.matrix() %>% 
            rowOrderStats(which = n_cancer + 1 - pan_bias)
                
        current_iter <- current_iter %>% 
            select(iteration, chromosome, position, key, significance) 
                
        full_iter <- bind_rows(full_iter, current_iter)
        
        nested_mafs$full_positions <- map(nested_mafs$cancer_type, function(x) current_iter %>% select(- iteration))
                   
    }
    
    full_iter <- full_iter %>% 
        group_by(iteration) %>% 
        nest()    
    
    full_iter$jump_length <- (starting_window/coverage)/(zoom**(full_iter$iteration - 1))
    
    return(full_iter)
    
}                                                          
                                                           
                                                           